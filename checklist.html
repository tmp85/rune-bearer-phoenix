<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rune Bearer Schedule Tracker</title>
    <!-- Firebase Scripts for Remote Control -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script src="js/firebaseConfig.js"></script>
    <style>
        :root {
            --primary-purple: #8b5cf6;
            --secondary-purple: #a78bfa;
            --dark-purple: #6d28d9;
            --success-green: #10b981;
            --warning-orange: #f59e0b;
            --text-light: #f8fafc;
            --text-gray: #64748b;
            --bg-dark: #1e293b;
            --bg-darker: #0f172a;
            --border-color: rgba(139, 92, 246, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-darker), var(--bg-dark));
            color: var(--text-light);
            min-height: 100vh;
            line-height: 1.6;
        }

        .header {
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, var(--primary-purple), var(--secondary-purple));
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.3);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .progress-summary {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 1.5rem;
            background: rgba(139, 92, 246, 0.1);
            border-bottom: 1px solid var(--border-color);
        }

        .progress-item {
            text-align: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            min-width: 150px;
        }

        .progress-number {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary-purple);
        }

        .progress-label {
            font-size: 0.9rem;
            color: var(--text-gray);
            margin-top: 0.5rem;
        }

        .admin-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
        }

        .admin-btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--dark-purple), var(--primary-purple));
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .admin-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }

        .admin-btn.reset {
            background: linear-gradient(135deg, #dc2626, #ef4444);
        }

        .action-controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-width: 200px;
        }

        .activation-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bulk-complete-section {
            display: flex;
            flex-direction: column;
        }

        .bulk-complete-btn {
            padding: 0.5rem 0.75rem;
            background: linear-gradient(135deg, var(--success-green), #059669);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: left;
        }

        .bulk-complete-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            background: linear-gradient(135deg, #059669, #047857);
        }

        .bulk-complete-btn.completed {
            background: linear-gradient(135deg, var(--text-gray), #475569);
            color: #cbd5e1;
            cursor: not-allowed;
        }

        .bulk-complete-btn:disabled {
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }

        .table-container {
            margin: 0 auto;
            max-width: 1400px;
            padding: 2rem;
            overflow-x: auto;
        }

        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .schedule-table th {
            background: linear-gradient(135deg, var(--dark-purple), var(--primary-purple));
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid var(--border-color);
        }

        .schedule-table td {
            padding: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.3s ease;
        }

        .schedule-table tr:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        .day-row.completed {
            background: rgba(16, 185, 129, 0.2);
        }

        .day-row.locked {
            background: rgba(100, 116, 139, 0.2);
            opacity: 0.6;
        }

        .character-section {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid transparent;
        }

        .character-section.wells {
            border-left-color: var(--warning-orange);
        }

        .character-section.rou {
            border-left-color: #3b82f6;
        }

        .character-name {
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .character-info {
            font-size: 0.9rem;
            color: var(--text-gray);
        }

        .completion-checkbox {
            transform: scale(1.2);
            margin-right: 0.5rem;
        }

        .completion-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-badge.completed {
            background: var(--success-green);
            color: white;
        }

        .status-badge.locked {
            background: var(--text-gray);
            color: white;
        }

        .status-badge.available {
            background: var(--primary-purple);
            color: white;
        }

        .task-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .task-type {
            font-weight: 600;
            color: var(--primary-purple);
        }

        .rune-info {
            font-size: 0.9rem;
        }

        .rune-name {
            color: var(--warning-orange);
            font-weight: 600;
        }

        .loot-tier {
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .loot-tier.tiny {
            background: rgba(139, 92, 246, 0.3);
            color: var(--secondary-purple);
        }

        .loot-tier.medium {
            background: rgba(245, 158, 11, 0.3);
            color: var(--warning-orange);
        }

        .loot-tier.big {
            background: rgba(16, 185, 129, 0.3);
            color: var(--success-green);
        }

        .special-room {
            color: var(--warning-orange);
            font-weight: 600;
        }

        /* Day Activation Controls */
        .activation-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: center;
        }

        .activation-toggle {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .activation-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .activation-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #64748b;
            transition: .4s;
            border-radius: 34px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .activation-slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        .activation-toggle input:checked + .activation-slider {
            background-color: var(--success-green);
        }

        .activation-toggle input:checked + .activation-slider:before {
            transform: translateX(26px);
        }

        .activation-toggle.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .activation-toggle.disabled .activation-slider {
            cursor: not-allowed;
            background-color: #374151;
        }

        .activation-label {
            font-size: 0.8rem;
            text-align: center;
            margin-top: 0.25rem;
            font-weight: 600;
        }

        .activation-label.active {
            color: var(--success-green);
        }

        .activation-label.inactive {
            color: var(--text-gray);
        }

        .activation-label.disabled {
            color: #6b7280;
        }

        .prerequisite-warning {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid var(--warning-orange);
            color: var(--warning-orange);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.8rem;
            text-align: center;
            margin: 0.25rem 0;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: var(--bg-darker);
            color: var(--text-light);
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            border: 1px solid var(--border-color);
            font-size: 0.75rem;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--bg-darker) transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .progress-summary {
                flex-direction: column;
                gap: 1rem;
            }

            .admin-controls {
                flex-direction: column;
                align-items: center;
            }

            .table-container {
                padding: 1rem;
            }

            .schedule-table th,
            .schedule-table td {
                padding: 0.5rem;
                font-size: 0.9rem;
            }

            .activation-toggle {
                width: 50px;
                height: 28px;
            }

            .activation-slider:before {
                height: 20px;
                width: 20px;
                left: 2px;
                bottom: 2px;
            }

            .activation-toggle input:checked + .activation-slider:before {
                transform: translateX(22px);
            }

                    .tooltip .tooltiptext {
            width: 150px;
            margin-left: -75px;
            font-size: 0.7rem;
        }
    }

    /* Reset Panel Styles */
    .reset-panel {
        background: rgba(0, 0, 0, 0.4);
        margin: 1rem auto;
        max-width: 1400px;
        border-radius: 12px;
        border: 2px solid #dc2626;
        box-shadow: 0 8px 32px rgba(220, 38, 38, 0.3);
        animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .reset-header {
        background: linear-gradient(135deg, #dc2626, #ef4444);
        padding: 1.5rem;
        border-radius: 10px 10px 0 0;
        text-align: center;
    }

    .reset-header h2 {
        margin-bottom: 0.5rem;
        font-size: 1.8rem;
    }

    .reset-controls {
        display: flex;
        justify-content: center;
        gap: 1rem;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.05);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        flex-wrap: wrap;
    }

    .reset-btn {
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
        background: linear-gradient(135deg, var(--dark-purple), var(--primary-purple));
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .reset-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
    }

    .reset-btn.warning {
        background: linear-gradient(135deg, #f59e0b, #fbbf24);
    }

    .reset-btn.danger {
        background: linear-gradient(135deg, #dc2626, #ef4444);
    }

    .reset-weeks-container {
        padding: 1.5rem;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1.5rem;
    }

    .reset-week {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .reset-week-header {
        text-align: center;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .reset-week-title {
        font-size: 1.2rem;
        font-weight: bold;
        color: var(--primary-purple);
        margin-bottom: 0.25rem;
    }

    .reset-week-range {
        font-size: 0.9rem;
        color: var(--text-gray);
    }

    .reset-days-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 0.5rem;
    }

    .reset-day-btn {
        padding: 0.5rem;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 600;
        transition: all 0.3s ease;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 60px;
        justify-content: center;
    }

    .reset-day-btn.locked {
        background: linear-gradient(135deg, #64748b, #94a3b8);
        color: white;
        opacity: 0.6;
        cursor: not-allowed;
    }

    .reset-day-btn.unlocked {
        background: linear-gradient(135deg, var(--dark-purple), var(--primary-purple));
        color: white;
    }

    .reset-day-btn.completed {
        background: linear-gradient(135deg, #059669, #10b981);
        color: white;
    }

    .reset-day-btn:not(.locked):hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
    }

    .reset-day-btn.completed:hover {
        box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
    }

    .day-number {
        font-size: 1rem;
        font-weight: bold;
    }

    .day-status {
        font-size: 0.7rem;
        margin-top: 0.25rem;
        opacity: 0.9;
    }

    .reset-week-controls {
        margin-top: 1rem;
        text-align: center;
        padding-top: 1rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .reset-week-btn {
        padding: 0.4rem 0.8rem;
        background: linear-gradient(135deg, #dc2626, #ef4444);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 600;
        transition: all 0.3s ease;
    }

    .reset-week-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 10px rgba(220, 38, 38, 0.4);
    }

    @media (max-width: 768px) {
        .reset-weeks-container {
            grid-template-columns: 1fr;
            padding: 1rem;
        }
        
        .reset-controls {
            flex-direction: column;
            align-items: center;
        }
        
        .reset-days-grid {
            grid-template-columns: repeat(3, 1fr);
        }
    }
    </style>
</head>
<body>
    <div class="header">
        <h1>🏰 Admin Progress Checklist</h1>
        <p>Manage Wells and Rou's progress through their 40-day adventure</p>
    </div>

    <!-- Firebase Remote Control Center -->
    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #7c3aed; border-radius: 20px; padding: 25px; margin: 20px auto; max-width: 1200px; box-shadow: 0 8px 32px rgba(124, 58, 237, 0.3);">
        <h2 style="color: #a78bfa; text-align: center; margin-top: 0; font-size: 24px;">
            🔥 Firebase Cloud Sync Control 🔥
        </h2>
        
        <div style="background: rgba(124, 58, 237, 0.2); border-radius: 10px; padding: 15px; margin-bottom: 20px; text-align: center; color: #e9d5ff; font-family: monospace;">
            <span id="firebaseStatus">Loading cloud status...</span>
        </div>
        
        <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 20px;">
            <button onclick="pushCurrentSaveAsMaster()" style="background: #7c3aed; color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(124, 58, 237, 0.4);">
                📤 Push as Master Save
            </button>
            <button onclick="viewFirebaseSave()" style="background: #6366f1; color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);">
                📥 Check Cloud Status
            </button>
            <button onclick="pullFromCloud()" style="background: #8b5cf6; color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);">
                ⬇️ Pull Cloud Save
            </button>
            <button onclick="forceCloudSync()" style="background: #ec4899; color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(236, 72, 153, 0.4);">
                🔄 Force Sync All
            </button>
        </div>
        
        <div style="background: rgba(124, 58, 237, 0.2); border-radius: 10px; padding: 15px;">
            <h3 style="color: #a78bfa; margin-top: 0; text-align: center;">Set Cloud Progress</h3>
            <div style="display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap;">
                <label style="color: #e9d5ff;">Wells Day: 
                    <input type="number" id="remoteWellsDay" value="1" min="1" max="40" style="width: 60px; padding: 5px; background: #2d2d44; color: white; border: 1px solid #7c3aed; border-radius: 5px; margin-left: 5px;">
                </label>
                <label style="color: #e9d5ff;">Rou Day: 
                    <input type="number" id="remoteRouDay" value="1" min="1" max="40" style="width: 60px; padding: 5px; background: #2d2d44; color: white; border: 1px solid #7c3aed; border-radius: 5px; margin-left: 5px;">
                </label>
                <button onclick="setRemoteProgress()" style="background: #10b981; color: white; border: none; padding: 8px 20px; border-radius: 8px; font-weight: bold; cursor: pointer;">
                    ☁️ Update Cloud
                </button>
            </div>
        </div>
    </div>

    <div class="progress-summary">
        <div class="progress-item">
            <div class="progress-number" id="wellsProgress">0</div>
            <div class="progress-label">Wells Completed</div>
        </div>
        <div class="progress-item">
            <div class="progress-number" id="rouProgress">0</div>
            <div class="progress-label">Rou Completed</div>
        </div>
        <div class="progress-item">
            <div class="progress-number" id="totalProgress">0</div>
            <div class="progress-label">Total Days Unlocked</div>
        </div>
    </div>

    <div class="admin-controls">
        <button class="admin-btn" onclick="window.location.href='index.html'">🎮 Return to Game</button>
        
        <button class="admin-btn" onclick="unlockNextDay()">🔓 Unlock Next Day</button>
        <button class="admin-btn reset" onclick="resetProgress()">🔄 Reset All Progress</button>
        <button class="admin-btn" onclick="exportProgress()">📥 Export Progress</button>
        <button class="admin-btn" onclick="toggleResetPanel()">🎯 Reset Individual Days</button>
        <button class="admin-btn" onclick="activateAdminScreensaver()" title="Activate Screensaver">🖥️</button>
    </div>

    <!-- Reset Days Panel -->
    <div id="resetPanel" class="reset-panel" style="display: none;">
        <div class="reset-header">
            <h2>🎯 Reset Individual Days</h2>
            <p>Reset specific days back to "never started" state. This will clear all progress, runes, and loot for the selected day.</p>
        </div>
        
        <div class="reset-controls">
            <button class="reset-btn danger" onclick="resetAllProgress()">🔄 Reset All Progress</button>
            <button class="reset-btn warning" onclick="resetWeek('current')">📅 Reset Current Week</button>
            <button class="reset-btn" onclick="toggleResetPanel()">❌ Close Panel</button>
        </div>

        <div class="reset-weeks-container">
            <!-- Week blocks will be generated dynamically -->
        </div>
    </div>

    <div class="table-container">
        <table class="schedule-table">
            <thead>
                <tr>
                    <th>Day</th>
                    <th>Date</th>
                    <th>Wells Progress</th>
                    <th>Rou Progress</th>
                    <th>Status</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="scheduleTableBody">
                <!-- Table rows will be generated dynamically -->
            </tbody>
        </table>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script src="js/saveManager.js"></script>
    <script src="gameSchedule.js"></script>
    <script>
        // Progress tracking state - SHARED with index.html
        let progressState = {
            currentDay: 1,
            completedDays: [],
            unlockedDays: [1],
            taskCompletions: {},
            collectedRunes: {
                wells: [],
                rou: []
            }
        };

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            loadProgress();
            generateScheduleTable();
            updateProgressSummary();
        });

        // Load progress from localStorage - SHARED KEY
        function loadProgress() {
            const saved = localStorage.getItem('runeBearer_progress');
            if (saved) {
                const data = JSON.parse(saved);
                progressState = {
                    currentDay: data.currentDay || 1,
                    completedDays: data.completedDays || [],
                    unlockedDays: data.unlockedDays || [1],
                    taskCompletions: data.taskCompletions || {},
                    collectedRunes: data.collectedRunes || {
                        wells: [],
                        rou: []
                    }
                };
            }
        }

        // Save progress to localStorage - SHARED KEY
        function saveProgress() {
            localStorage.setItem('runeBearer_progress', JSON.stringify(progressState));
        }

        // Generate the main schedule table
        function generateScheduleTable() {
            const tbody = document.getElementById('scheduleTableBody');
            tbody.innerHTML = '';

            gameSchedule.schedule.forEach(dayData => {
                const row = document.createElement('tr');
                row.className = 'day-row';
                
                // Determine row status using new data structure
                const wellsCompleted = progressState.taskCompletions[`day${dayData.day}_wells`] || false;
                const rouCompleted = progressState.taskCompletions[`day${dayData.day}_rou`] || false;
                const bothCompleted = wellsCompleted && rouCompleted;
                const isLocked = !progressState.unlockedDays.includes(dayData.day);
                
                if (bothCompleted) {
                    row.classList.add('completed');
                } else if (isLocked) {
                    row.classList.add('locked');
                }

                row.innerHTML = `
                    <td>
                        <strong>Day ${dayData.day}</strong><br>
                        <small>${dayData.dayOfWeek}</small>
                    </td>
                    <td>${dayData.date}</td>
                    <td>${generateCharacterCell(dayData.wells, 'wells', dayData.day, isLocked)}</td>
                    <td>${generateCharacterCell(dayData.rou, 'rou', dayData.day, isLocked)}</td>
                    <td>${generateStatusCell(wellsCompleted, rouCompleted, isLocked)}</td>
                    <td>${generateActivationCell(dayData.day, isLocked)}</td>
                `;

                tbody.appendChild(row);
            });
        }

        // Generate character cell content
        function generateCharacterCell(charData, character, day, isLocked) {
            const isCompleted = progressState.taskCompletions[`day${day}_${character}`] || false;
            const checkboxDisabled = isLocked ? 'disabled' : '';
            
            return `
                <div class="character-section ${character}">
                    <div class="completion-status">
                        <input type="checkbox" 
                               class="completion-checkbox" 
                               ${isCompleted ? 'checked' : ''} 
                               ${checkboxDisabled}
                               onchange="handleComplete(${day}, '${character}')">
                        <span class="character-name">${character.charAt(0).toUpperCase() + character.slice(1)}</span>
                    </div>
                    <div class="character-info">
                        <div><strong>${charData.realm}</strong></div>
                        <div class="${charData.isSubBoss || charData.isBoss || charData.isChickenJockey ? 'special-room' : ''}">${charData.room}</div>
                        <div class="task-info">
                            ${charData.irlTask ? `<span class="task-type">IRL: ${charData.irlTask}</span>` : '<span class="task-type">Math Only</span>'}
                            ${charData.runeDropped ? `<div class="rune-info">🔮 <span class="rune-name">${charData.runeDropped}</span></div>` : ''}
                            ${charData.lootTier && charData.lootTier !== 'None' ? `<span class="loot-tier ${charData.lootTier.toLowerCase()}">${charData.lootTier} Loot</span>` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        // Generate status cell content
        function generateStatusCell(wellsCompleted, rouCompleted, isLocked) {
            if (isLocked) {
                return '<span class="status-badge locked">🔒 Locked</span>';
            } else if (wellsCompleted && rouCompleted) {
                return '<span class="status-badge completed">✅ Complete</span>';
            } else {
                return '<span class="status-badge available">⭐ Available</span>';
            }
        }

        // Generate activation control cell content
        function generateActivationCell(day, isLocked) {
            const isActive = progressState.unlockedDays.includes(day);
            const canActivate = canActivateDay(day);
            const isDisabled = !canActivate && !isActive;
            
            // Check if already completed through this day
            const isCompletedThrough = isCompletedThroughDay(day);
            const currentProgress = getCurrentDayProgress();
            
            let tooltipText = '';
            if (day === 1) {
                tooltipText = 'Day 1 can always be activated';
            } else if (!canActivate && !isActive) {
                tooltipText = `Day ${day - 1} must be activated first`;
            } else if (isActive) {
                tooltipText = `Click to deactivate Day ${day}`;
            } else {
                tooltipText = `Click to activate Day ${day}`;
            }
            
            // Generate cumulative completion button
            let bulkCompleteButton = '';
            if (isCompletedThrough) {
                bulkCompleteButton = `
                    <button class="bulk-complete-btn completed" disabled>
                        ✓ Completed
                    </button>
                `;
            } else {
                const progressText = currentProgress < day ? ` (Currently: Day ${currentProgress})` : '';
                bulkCompleteButton = `
                    <button class="bulk-complete-btn" onclick="handleBulkComplete(${day})">
                        🏆 Complete Through Day ${day}${progressText}
                    </button>
                `;
            }
            
            return `
                <div class="action-controls">
                    <div class="activation-section">
                        <div class="tooltip">
                            <label class="activation-toggle ${isDisabled ? 'disabled' : ''}">
                                <input type="checkbox" 
                                       ${isActive ? 'checked' : ''} 
                                       ${isDisabled ? 'disabled' : ''}
                                       onchange="handleDayActivation(${day}, this.checked)">
                                <span class="activation-slider"></span>
                            </label>
                            <span class="tooltiptext">${tooltipText}</span>
                        </div>
                        <div class="activation-label ${isActive ? 'active' : (isDisabled ? 'disabled' : 'inactive')}">
                            ${isActive ? 'Active' : (isDisabled ? 'Locked' : 'Inactive')}
                        </div>
                    </div>
                    <div class="bulk-complete-section">
                        ${bulkCompleteButton}
                    </div>
                </div>
            `;
        }

        // Check if a day can be activated (sequential rule)
        function canActivateDay(day) {
            if (day === 1) return true; // Day 1 can always be activated
            return progressState.unlockedDays.includes(day - 1); // Previous day must be active
        }

        // Check if all days through a specific day are completed
        function isCompletedThroughDay(targetDay) {
            for (let day = 1; day <= targetDay; day++) {
                const wellsCompleted = progressState.taskCompletions[`day${day}_wells`] || false;
                const rouCompleted = progressState.taskCompletions[`day${day}_rou`] || false;
                if (!wellsCompleted || !rouCompleted) {
                    return false;
                }
            }
            return true;
        }

        // Get the current highest completed day
        function getCurrentDayProgress() {
            let currentProgress = 0;
            for (let day = 1; day <= 40; day++) {
                const wellsCompleted = progressState.taskCompletions[`day${day}_wells`] || false;
                const rouCompleted = progressState.taskCompletions[`day${day}_rou`] || false;
                if (wellsCompleted && rouCompleted) {
                    currentProgress = day;
                } else {
                    break;
                }
            }
            return currentProgress;
        }

        // Handle bulk completion through a specific day
        function handleBulkComplete(targetDay) {
            const currentProgress = getCurrentDayProgress();
            
            // Show confirmation dialog
            const confirmMessage = `This will complete Days 1-${targetDay} for both Wells and Rou.\n\n` +
                                 `This includes:\n` +
                                 `• Marking all days as completed\n` +
                                 `• Awarding all runes and loot through Day ${targetDay}\n` +
                                 `• Updating progress counters\n` +
                                 `• Activating all days through Day ${targetDay}\n\n` +
                                 `Continue?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Complete all days through target day
            for (let day = 1; day <= targetDay; day++) {
                // Ensure day is unlocked
                if (!progressState.unlockedDays.includes(day)) {
                    progressState.unlockedDays.push(day);
                }
                
                // Mark both players as completed for this day
                progressState.taskCompletions[`day${day}_wells`] = true;
                progressState.taskCompletions[`day${day}_rou`] = true;
                
                // Add to completed days
                if (!progressState.completedDays.includes(day)) {
                    progressState.completedDays.push(day);
                }
                
                // Collect runes for completed day
                collectRunesForCompletedDay(day);
            }
            
            // Sort arrays
            progressState.unlockedDays.sort((a, b) => a - b);
            progressState.completedDays.sort((a, b) => a - b);
            
            // Update current day to next incomplete day
            let nextDay = targetDay + 1;
            progressState.currentDay = nextDay <= 40 ? nextDay : 40;
            
            // Auto-unlock next day if exists
            if (nextDay <= 40 && !progressState.unlockedDays.includes(nextDay)) {
                progressState.unlockedDays.push(nextDay);
                progressState.unlockedDays.sort((a, b) => a - b);
            }
            
            console.log(`Bulk completed Days 1-${targetDay} for both players`);
            
            saveProgress();
            generateScheduleTable();
            updateProgressSummary();
        }

        // Handle day activation/deactivation
        function handleDayActivation(day, isActivating) {
            if (isActivating) {
                // Activating a day
                if (!canActivateDay(day)) {
                    // Show warning and revert checkbox
                    const checkbox = event.target;
                    checkbox.checked = false;
                    
                    // Show warning message
                    const warningDiv = document.createElement('div');
                    warningDiv.className = 'prerequisite-warning';
                    warningDiv.textContent = `Cannot activate Day ${day}. Day ${day - 1} must be activated first.`;
                    warningDiv.style.position = 'fixed';
                    warningDiv.style.top = '20px';
                    warningDiv.style.left = '50%';
                    warningDiv.style.transform = 'translateX(-50%)';
                    warningDiv.style.zIndex = '1000';
                    warningDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                    
                    document.body.appendChild(warningDiv);
                    
                    // Remove warning after 3 seconds
                    setTimeout(() => {
                        if (warningDiv.parentNode) {
                            warningDiv.parentNode.removeChild(warningDiv);
                        }
                    }, 3000);
                    
                    return;
                }
                
                // Add day to unlocked days
                if (!progressState.unlockedDays.includes(day)) {
                    progressState.unlockedDays.push(day);
                    progressState.unlockedDays.sort((a, b) => a - b);
                    console.log(`Day ${day} manually activated`);
                }
            } else {
                // Deactivating a day
                if (hasProgressOrDependencies(day)) {
                    // Show confirmation dialog
                    const confirmMessage = `Deactivating Day ${day} will:\n` +
                                         `• Remove any progress on Day ${day}\n` +
                                         `• Deactivate all subsequent days\n` +
                                         `• Remove collected runes for affected days\n\n` +
                                         `Are you sure you want to continue?`;
                    
                    if (!confirm(confirmMessage)) {
                        // Revert checkbox
                        event.target.checked = true;
                        return;
                    }
                }
                
                // Deactivate this day and all subsequent days
                deactivateDayAndSubsequent(day);
            }
            
            saveProgress();
            generateScheduleTable();
            updateProgressSummary();
        }

        // Check if a day has progress or dependencies
        function hasProgressOrDependencies(day) {
            // Check if day has any completed tasks
            const hasProgress = progressState.taskCompletions[`day${day}_wells`] || 
                              progressState.taskCompletions[`day${day}_rou`];
            
            // Check if any subsequent days are unlocked
            const hasSubsequentDays = progressState.unlockedDays.some(d => d > day);
            
            return hasProgress || hasSubsequentDays;
        }

        // Deactivate a day and all subsequent days
        function deactivateDayAndSubsequent(startDay) {
            const affectedDays = progressState.unlockedDays.filter(d => d >= startDay);
            
            // Remove from unlocked days
            progressState.unlockedDays = progressState.unlockedDays.filter(d => d < startDay);
            
            // Remove progress for affected days
            affectedDays.forEach(day => {
                delete progressState.taskCompletions[`day${day}_wells`];
                delete progressState.taskCompletions[`day${day}_rou`];
                
                // Remove from completed days
                progressState.completedDays = progressState.completedDays.filter(d => d !== day);
                
                // Remove runes for affected days
                removeRunesForDay(day);
            });
            
            // FIXED: Update current day and ensure proper day availability
            if (startDay === 1) {
                // Special case: if deactivating Day 1, keep it as current (no days unlocked)
                progressState.currentDay = 1;
            } else {
                // For other days: set current day to the day being deactivated (making it available)
                progressState.currentDay = startDay;
                
                // Ensure the deactivated day is still available to play
                if (!progressState.unlockedDays.includes(startDay)) {
                    progressState.unlockedDays.push(startDay);
                    progressState.unlockedDays.sort((a, b) => a - b);
                }
            }
            
            console.log(`Deactivated Days ${startDay}-${Math.max(...affectedDays)} and removed their progress. Current day is now ${progressState.currentDay}`);
        }

        // Debug function to check current progress state
        function debugProgressState() {
            console.log('Current Progress State:', progressState);
            console.log('Day 4 Rou Completion:', progressState.taskCompletions['day4_rou']);
            console.log('Day 4 Wells Completion:', progressState.taskCompletions['day4_wells']);
            
            // Show specific info for day 4
            alert(`Day 4 Status:\nRou: ${progressState.taskCompletions['day4_rou'] ? 'COMPLETED' : 'NOT COMPLETED'}\nWells: ${progressState.taskCompletions['day4_wells'] ? 'COMPLETED' : 'NOT COMPLETED'}`);
        }

        // Fix function to reset both Wells and Rou Day 4
        function fixDay4Completion() {
            const confirmReset = confirm('This will reset BOTH Wells and Rou Day 4 back to NOT COMPLETED. Continue?');
            if (confirmReset) {
                progressState.taskCompletions['day4_rou'] = false;
                progressState.taskCompletions['day4_wells'] = false;
                
                // Remove Day 4 from completed days entirely
                const index = progressState.completedDays.indexOf(4);
                if (index > -1) {
                    progressState.completedDays.splice(index, 1);
                }
                
                saveProgress();
                generateScheduleTable();
                updateProgressSummary();
                alert('Both Wells and Rou Day 4 have been reset to NOT COMPLETED');
            }
        }

        // Fix function to reset Rou Day 4 specifically  
        function fixRouDay4() {
            const confirmReset = confirm('This will reset Rou Day 4 back to NOT COMPLETED. Continue?');
            if (confirmReset) {
                progressState.taskCompletions['day4_rou'] = false;
                
                // Also remove from completed days if no other player completed it
                const wellsDay4 = progressState.taskCompletions['day4_wells'] || false;
                if (!wellsDay4) {
                    const index = progressState.completedDays.indexOf(4);
                    if (index > -1) {
                        progressState.completedDays.splice(index, 1);
                    }
                }
                
                saveProgress();
                generateScheduleTable();
                updateProgressSummary();
                alert('Rou Day 4 has been reset to NOT COMPLETED');
            }
        }

        // Fix function to reset Wells Day 4 specifically
        function fixWellsDay4() {
            const confirmReset = confirm('This will reset Wells Day 4 back to NOT COMPLETED. Continue?');
            if (confirmReset) {
                progressState.taskCompletions['day4_wells'] = false;
                
                // Also remove from completed days if no other player completed it
                const rouDay4 = progressState.taskCompletions['day4_rou'] || false;
                if (!rouDay4) {
                    const index = progressState.completedDays.indexOf(4);
                    if (index > -1) {
                        progressState.completedDays.splice(index, 1);
                    }
                }
                
                saveProgress();
                generateScheduleTable();
                updateProgressSummary();
                alert('Wells Day 4 has been reset to NOT COMPLETED');
            }
        }

        // Handle completion checkbox changes
        function handleComplete(day, character) {
            const checkbox = event.target;
            progressState.taskCompletions[`day${day}_${character}`] = checkbox.checked;
            
            // Check if both characters completed this day
            const wellsCompleted = progressState.taskCompletions[`day${day}_wells`] || false;
            const rouCompleted = progressState.taskCompletions[`day${day}_rou`] || false;
            
            if (wellsCompleted && rouCompleted) {
                // Mark day as completed
                if (!progressState.completedDays.includes(day)) {
                    progressState.completedDays.push(day);
                    progressState.completedDays.sort((a, b) => a - b);
                    
                    // SILENT RUNE COLLECTION - Add runes when day is completed
                    collectRunesForCompletedDay(day);
                }
                
                // Update current day to next incomplete day
                let nextDay = day + 1;
                while (nextDay <= 40 && progressState.completedDays.includes(nextDay)) {
                    nextDay++;
                }
                progressState.currentDay = nextDay <= 40 ? nextDay : 40;
                
                // Auto-advance unlocked days
                if (!progressState.unlockedDays.includes(nextDay) && nextDay <= 40) {
                    progressState.unlockedDays.push(nextDay);
                    progressState.unlockedDays.sort((a, b) => a - b);
                    console.log(`Day ${day} completed by both! Unlocked Day ${nextDay}`);
                }
            } else {
                // Remove from completed days if unchecked
                if (!checkbox.checked) {
                    progressState.completedDays = progressState.completedDays.filter(d => d !== day);
                    
                    // Remove runes if day is uncompleted
                    removeRunesForDay(day);
                }
            }
            
            saveProgress();
            generateScheduleTable();
            updateProgressSummary();
        }

        // Update progress summary
        function updateProgressSummary() {
            const wellsCount = Object.keys(progressState.taskCompletions).filter(key => 
                key.includes('_wells') && progressState.taskCompletions[key]).length;
            const rouCount = Object.keys(progressState.taskCompletions).filter(key => 
                key.includes('_rou') && progressState.taskCompletions[key]).length;
            
            document.getElementById('wellsProgress').textContent = `${wellsCount}/40`;
            document.getElementById('rouProgress').textContent = `${rouCount}/40`;
            document.getElementById('totalProgress').textContent = progressState.unlockedDays.length;
        }

        // Admin function: Unlock next day
        function unlockNextDay() {
            const maxUnlocked = Math.max(...progressState.unlockedDays);
            if (maxUnlocked < 40) {
                const nextDay = maxUnlocked + 1;
                if (!progressState.unlockedDays.includes(nextDay)) {
                    progressState.unlockedDays.push(nextDay);
                    progressState.unlockedDays.sort((a, b) => a - b);
                    saveProgress();
                    generateScheduleTable();
                    updateProgressSummary();
                    console.log(`Manually unlocked Day ${nextDay}`);
                }
            } else {
                alert('All days are already unlocked!');
            }
        }



        // SILENT RUNE COLLECTION FUNCTIONS
        function collectRunesForCompletedDay(day) {
            const dayData = gameSchedule.schedule.find(d => d.day === day);
            if (!dayData) return;
            
            // Add Wells rune if it exists
            if (dayData.wells.runeDropped) {
                addRuneToCollection('wells', dayData.wells.runeDropped);
            }
            
            // Add Rou rune if it exists
            if (dayData.rou.runeDropped) {
                addRuneToCollection('rou', dayData.rou.runeDropped);
            }
        }
        
        function addRuneToCollection(character, runeName) {
            if (!progressState.collectedRunes) {
                progressState.collectedRunes = { wells: [], rou: [] };
            }
            
            if (!progressState.collectedRunes[character].includes(runeName)) {
                progressState.collectedRunes[character].push(runeName);
                console.log(`Silently collected rune: ${runeName} for ${character}`);
            }
        }
        
        function removeRunesForDay(day) {
            const dayData = gameSchedule.schedule.find(d => d.day === day);
            if (!dayData) return;
            
            // Remove Wells rune if it exists
            if (dayData.wells.runeDropped) {
                progressState.collectedRunes.wells = progressState.collectedRunes.wells.filter(r => r !== dayData.wells.runeDropped);
            }
            
            // Remove Rou rune if it exists
            if (dayData.rou.runeDropped) {
                progressState.collectedRunes.rou = progressState.collectedRunes.rou.filter(r => r !== dayData.rou.runeDropped);
            }
        }

        // Admin function: Reset all progress
        function resetProgress() {
            if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                // Clear localStorage first
                localStorage.removeItem('runeBearer_progress');
                
                // Reset state
                progressState = {
                    currentDay: 1,
                    completedDays: [],
                    unlockedDays: [1],
                    taskCompletions: {},
                    collectedRunes: {
                        wells: [],
                        rou: []
                    }
                };
                
                // Save the reset state
                saveProgress();
                
                // Force update UI
                generateScheduleTable();
                updateProgressSummary();
                
                // Provide feedback
                alert('Progress has been reset to Day 1');
                console.log('Progress reset to Day 1');
                
                // Force reload to ensure clean state
                window.location.reload();
            }
        }

        // Export progress as JSON
        function exportProgress() {
            const dataStr = JSON.stringify(progressState, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = 'rune-bearer-progress.json';
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }

        // Reset Panel Functions
        function toggleResetPanel() {
            const panel = document.getElementById('resetPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                generateResetPanel();
            } else {
                panel.style.display = 'none';
            }
        }

        function generateResetPanel() {
            const container = document.querySelector('.reset-weeks-container');
            container.innerHTML = '';

            // Group days into weeks (8 weeks total for 40 days)
            const weeks = [];
            for (let week = 1; week <= 8; week++) {
                const startDay = (week - 1) * 5 + 1;
                const endDay = Math.min(week * 5, 40);
                weeks.push({
                    week,
                    startDay,
                    endDay,
                    days: Array.from({length: endDay - startDay + 1}, (_, i) => startDay + i)
                });
            }

            weeks.forEach(weekData => {
                const weekElement = document.createElement('div');
                weekElement.className = 'reset-week';
                
                const weekHeader = `
                    <div class="reset-week-header">
                        <div class="reset-week-title">Week ${weekData.week}</div>
                        <div class="reset-week-range">Days ${weekData.startDay}-${weekData.endDay}</div>
                    </div>
                `;

                const daysGrid = weekData.days.map(day => {
                    const dayStatus = getDayResetStatus(day);
                    return `
                        <button class="reset-day-btn ${dayStatus.class}" 
                                onclick="resetIndividualDay(${day})"
                                ${dayStatus.disabled ? 'disabled' : ''}>
                            <div class="day-number">${day}</div>
                            <div class="day-status">${dayStatus.status}</div>
                        </button>
                    `;
                }).join('');

                const weekControls = `
                    <div class="reset-week-controls">
                        <button class="reset-week-btn" onclick="resetWeek(${weekData.week})">
                            Reset Week ${weekData.week}
                        </button>
                    </div>
                `;

                weekElement.innerHTML = `
                    ${weekHeader}
                    <div class="reset-days-grid">
                        ${daysGrid}
                    </div>
                    ${weekControls}
                `;

                container.appendChild(weekElement);
            });
        }

        function getDayResetStatus(day) {
            const isUnlocked = progressState.unlockedDays.includes(day);
            const wellsCompleted = progressState.taskCompletions[`day${day}_wells`] || false;
            const rouCompleted = progressState.taskCompletions[`day${day}_rou`] || false;
            const isCompleted = wellsCompleted || rouCompleted;
            const isFullyCompleted = wellsCompleted && rouCompleted;

            if (!isUnlocked) {
                return {
                    class: 'locked',
                    status: 'Locked',
                    disabled: true
                };
            } else if (isFullyCompleted) {
                return {
                    class: 'completed',
                    status: 'Complete',
                    disabled: false
                };
            } else if (isCompleted) {
                return {
                    class: 'completed',
                    status: 'Partial',
                    disabled: false
                };
            } else {
                return {
                    class: 'unlocked',
                    status: 'Unlocked',
                    disabled: false
                };
            }
        }

        function resetIndividualDay(day) {
            const dayStatus = getDayResetStatus(day);
            
            if (dayStatus.disabled) {
                alert(`Day ${day} is locked and cannot be reset.`);
                return;
            }

            // Check if resetting this day would break progression
            const hasSubsequentUnlocked = progressState.unlockedDays.some(d => d > day);
            const hasSubsequentCompleted = progressState.completedDays.some(d => d > day);
            
            let warningMessage = `Are you sure you want to reset Day ${day}?\n\nThis will:\n- Clear all progress for Day ${day}\n- Remove any runes collected on Day ${day}\n- Reset the day to "never started" state`;
            
            if (hasSubsequentUnlocked || hasSubsequentCompleted) {
                warningMessage += `\n\n⚠️ WARNING: This will also reset all days after Day ${day} to maintain progression logic.`;
            }

            if (confirm(warningMessage)) {
                performDayReset(day);
            }
        }

        function performDayReset(day) {
            console.log(`Resetting Day ${day}...`);
            
            // Remove from unlocked days (and all subsequent days)
            progressState.unlockedDays = progressState.unlockedDays.filter(d => d < day);
            
            // Remove from completed days (current day and all subsequent)
            progressState.completedDays = progressState.completedDays.filter(d => d < day);
            
            // Clear task completions for this day and all subsequent days
            Object.keys(progressState.taskCompletions).forEach(key => {
                const dayMatch = key.match(/day(\d+)_/);
                if (dayMatch && parseInt(dayMatch[1]) >= day) {
                    delete progressState.taskCompletions[key];
                }
            });
            
            // Remove runes for affected days
            for (let d = day; d <= 40; d++) {
                removeRunesForDay(d);
            }
            
            // FIXED: Update current day and unlock the reset day for play
            if (day === 1) {
                // Special case: if resetting Day 1, ensure it's unlocked and current
                if (!progressState.unlockedDays.includes(1)) {
                    progressState.unlockedDays.push(1);
                }
                progressState.currentDay = 1;
            } else {
                // For other days: set current day to the reset day and unlock it
                progressState.currentDay = day;
                
                // Ensure the reset day is available to play
                if (!progressState.unlockedDays.includes(day)) {
                    progressState.unlockedDays.push(day);
                    progressState.unlockedDays.sort((a, b) => a - b);
                }
            }
            
            // Save and update UI
            saveProgress();
            generateScheduleTable();
            updateProgressSummary();
            generateResetPanel();
            
            console.log(`Day ${day} reset successfully. Current day is now ${progressState.currentDay}`);
            alert(`Day ${day} has been reset and is now available to play!`);
        }

        function resetWeek(weekNumber) {
            let startDay, endDay;
            
            if (weekNumber === 'current') {
                // Find current week based on current day
                const currentDay = progressState.currentDay;
                const weekNum = Math.ceil(currentDay / 5);
                startDay = (weekNum - 1) * 5 + 1;
                endDay = Math.min(weekNum * 5, 40);
            } else {
                startDay = (weekNumber - 1) * 5 + 1;
                endDay = Math.min(weekNumber * 5, 40);
            }
            
            const weekText = weekNumber === 'current' ? 'current week' : `Week ${weekNumber}`;
            
            if (confirm(`Are you sure you want to reset ${weekText} (Days ${startDay}-${endDay})?\n\nThis will reset all progress for these days and may affect subsequent days to maintain progression logic.`)) {
                performDayReset(startDay);
            }
        }

        function resetAllProgress() {
            if (confirm('Are you sure you want to reset ALL progress? This will clear everything and cannot be undone.')) {
                resetProgress();
                generateResetPanel();
            }
        }

        // Sound Effects System (same as main game)
        class SoundManager {
            constructor() {
                this.sounds = {};
                this.isLoaded = false;
                this.volume = 0.7; // Default volume (70%)
                this.currentlyPlaying = null;
                this.audioContext = null;
                
                // Initialize audio context for better browser support
                this.initAudioContext();
                
                // Load all sound effects
                this.loadSounds();
            }

            initAudioContext() {
                try {
                    // Create audio context for better browser support
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    console.warn('Audio context not supported:', error);
                }
            }

            loadSounds() {
                const soundFiles = {
                    runeDiscovered: 'assets/audio/sfx/rune_discovered_epic.mp3',
                    lootTiny: 'assets/audio/sfx/loot_tiny_sparkle.mp3.mp3',  // Note: double .mp3 extension
                    lootMedium: 'assets/audio/sfx/loot_medium_chest.mp3',
                    lootBig: 'assets/audio/sfx/loot_big_legendary.mp3',
                    puzzleSolved: 'assets/audio/sfx/puzzle_mechanism_solved.mp3',
                    bossWarning: 'assets/audio/sfx/boss_encounter_warning.mp3',
                    roomTransition: 'assets/audio/sfx/room_portal_transition.mp3',
                    chickenJockey: 'assets/audio/sfx/chicken_jockey_battle.mp3',
                    musicMagic: 'assets/audio/sfx/irl_music_magic_echo.mp3'
                    // Note: journal_mystical_page.mp3 reserved for future use
                };

                let loadedCount = 0;
                const totalSounds = Object.keys(soundFiles).length;

                Object.entries(soundFiles).forEach(([key, url]) => {
                    const audio = new Audio();
                    
                    audio.preload = 'auto';
                    audio.volume = this.volume;
                    
                    audio.addEventListener('canplaythrough', () => {
                        loadedCount++;
                        console.log(`[Admin] Sound loaded: ${key}`);
                        
                        if (loadedCount === totalSounds) {
                            this.isLoaded = true;
                            console.log('[Admin] All sound effects loaded successfully');
                        }
                    });
                    
                    audio.addEventListener('error', (e) => {
                        console.error(`[Admin] Failed to load sound: ${key} from ${url}`, e);
                        loadedCount++; // Still count as "processed" to not block other sounds
                        
                        if (loadedCount === totalSounds) {
                            this.isLoaded = true;
                            console.log('[Admin] Sound loading complete (some may have failed)');
                        }
                    });
                    
                    audio.src = url;
                    this.sounds[key] = audio;
                });
            }

            play(soundKey, options = {}) {
                if (!this.isLoaded) {
                    console.warn('[Admin] Sound system not yet loaded, queueing sound:', soundKey);
                    // Retry after a short delay
                    setTimeout(() => this.play(soundKey, options), 100);
                    return;
                }

                const sound = this.sounds[soundKey];
                if (!sound) {
                    console.error('[Admin] Sound not found:', soundKey);
                    return;
                }

                try {
                    // Resume audio context if suspended (required by some browsers)
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }

                    // Stop currently playing sound if specified
                    if (options.stopCurrent && this.currentlyPlaying) {
                        this.currentlyPlaying.pause();
                        this.currentlyPlaying.currentTime = 0;
                    }

                    // Clone audio for overlapping sounds (if needed)
                    const audioToPlay = options.allowOverlap ? sound.cloneNode() : sound;
                    
                    // Set volume
                    audioToPlay.volume = options.volume || this.volume;
                    
                    // Reset to beginning
                    audioToPlay.currentTime = 0;
                    
                    // Play the sound
                    const playPromise = audioToPlay.play();
                    
                    if (playPromise !== undefined) {
                        playPromise
                            .then(() => {
                                console.log(`[Admin] Playing sound: ${soundKey}`);
                                this.currentlyPlaying = audioToPlay;
                            })
                            .catch(error => {
                                console.error('[Admin] Error playing sound:', soundKey, error);
                            });
                    }
                    
                } catch (error) {
                    console.error('[Admin] Error playing sound:', soundKey, error);
                }
            }

            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume)); // Clamp between 0 and 1
                
                // Update volume for all loaded sounds
                Object.values(this.sounds).forEach(audio => {
                    audio.volume = this.volume;
                });
                
                console.log('[Admin] Sound volume set to:', this.volume);
            }

            // Play rune discovery sound
            playRuneDiscovered() {
                this.play('runeDiscovered', { stopCurrent: false });
            }

            // Play loot sound based on tier
            playLootSound(lootTier) {
                if (!lootTier || lootTier === 'None') return;
                
                let soundKey;
                switch (lootTier.toLowerCase()) {
                    case 'tiny':
                        soundKey = 'lootTiny';
                        break;
                    case 'medium':
                        soundKey = 'lootMedium';
                        break;
                    case 'big':
                    case 'legendary':
                        soundKey = 'lootBig';
                        break;
                    default:
                        console.log('[Admin] Unknown loot tier:', lootTier);
                        soundKey = 'lootMedium'; // Default fallback
                }
                
                this.play(soundKey, { stopCurrent: false });
            }

            // Play puzzle solved sound
            playPuzzleSolved() {
                this.play('puzzleSolved', { stopCurrent: false });
            }

            // Play boss encounter warning sound
            playBossWarning() {
                this.play('bossWarning', { stopCurrent: false });
            }

            // Play room transition sound
            playRoomTransition() {
                this.play('roomTransition', { stopCurrent: false });
            }

            // Play chicken jockey battle sound
            playChickenJockey() {
                this.play('chickenJockey', { stopCurrent: false });
            }

            // Play IRL music magic completion sound
            playMusicMagic() {
                this.play('musicMagic', { stopCurrent: false });
            }

            // Test function for debugging
            testSound(soundKey) {
                console.log('[Admin] Testing sound:', soundKey);
                this.play(soundKey);
            }

            // Get status of sound system
            getStatus() {
                return {
                    loaded: this.isLoaded,
                    sounds: Object.keys(this.sounds),
                    volume: this.volume
                };
            }
        }

        // Initialize sound manager for admin interface
        const soundManager = new SoundManager();

        // Preview sounds for completed day content
        function previewDayEffects(day) {
            const dayData = gameSchedule.schedule.find(d => d.day === day);
            if (!dayData) return;

            let effectsFound = false;
            let delay = 100;
            
            // Check room type sounds first
            if (dayData.wells.isChickenJockey || dayData.rou.isChickenJockey) {
                console.log(`[Admin] Playing Chicken Jockey sound for Day ${day}`);
                setTimeout(() => soundManager.playChickenJockey(), delay);
                delay += 1000;
                effectsFound = true;
            } else if (dayData.wells.isBoss || dayData.wells.isSubBoss || dayData.rou.isBoss || dayData.rou.isSubBoss) {
                console.log(`[Admin] Playing Boss Warning sound for Day ${day}`);
                setTimeout(() => soundManager.playBossWarning(), delay);
                delay += 1000;
                effectsFound = true;
            }
            
            // Check Wells
            if (dayData.wells.runeDropped && dayData.wells.runeDropped !== 'None') {
                console.log(`[Admin] Playing Wells rune sound for Day ${day}: ${dayData.wells.runeDropped}`);
                setTimeout(() => soundManager.playRuneDiscovered(), delay);
                delay += 1000;
                effectsFound = true;
            }
            
            if (dayData.wells.lootTier && dayData.wells.lootTier !== 'None') {
                console.log(`[Admin] Playing Wells loot sound for Day ${day}: ${dayData.wells.lootTier}`);
                setTimeout(() => soundManager.playLootSound(dayData.wells.lootTier), delay);
                delay += 1000;
                effectsFound = true;
            }
            
            // Check Rou
            if (dayData.rou.runeDropped && dayData.rou.runeDropped !== 'None') {
                console.log(`[Admin] Playing Rou rune sound for Day ${day}: ${dayData.rou.runeDropped}`);
                setTimeout(() => soundManager.playRuneDiscovered(), delay);
                delay += 1000;
                effectsFound = true;
            }
            
            if (dayData.rou.lootTier && dayData.rou.lootTier !== 'None') {
                console.log(`[Admin] Playing Rou loot sound for Day ${day}: ${dayData.rou.lootTier}`);
                setTimeout(() => soundManager.playLootSound(dayData.rou.lootTier), delay);
                delay += 1000;
                effectsFound = true;
            }
            
            if (!effectsFound) {
                console.log(`[Admin] No sound effects for Day ${day}`);
                alert(`Day ${day} has no runes or loot (no sound effects to preview)`);
            }
        }

        // Expose admin test functions for debugging
        window.testAdminSound = function(soundKey) {
            soundManager.testSound(soundKey);
        };

        window.testAdminRuneSound = function() {
            soundManager.playRuneDiscovered();
        };

        window.testAdminLootSound = function(tier = 'medium') {
            soundManager.playLootSound(tier);
        };

        window.testAdminPuzzleSound = function() {
            soundManager.playPuzzleSolved();
        };

        window.testAdminBossSound = function() {
            soundManager.playBossWarning();
        };

        window.testAdminTransitionSound = function() {
            soundManager.playRoomTransition();
        };

        window.testAdminChickenJockeySound = function() {
            soundManager.playChickenJockey();
        };

        window.testAdminMusicMagicSound = function() {
            soundManager.playMusicMagic();
        };

        window.previewDayEffects = function(day) {
            previewDayEffects(day);
        };

        window.getAdminSoundStatus = function() {
            return soundManager.getStatus();
        };

        // Screensaver for Admin Interface (longer timeout)
        class AdminScreensaverManager {
            constructor() {
                this.isActive = false;
                this.inactivityTimer = null;
                this.slideTimer = null;
                this.currentImageIndex = 0;
                this.images = [];
                this.isLoading = true;
                
                // Configuration (longer timeout for admin interface)
                this.inactivityTimeout = 15 * 60 * 1000; // 15 minutes for admin
                this.slideInterval = 15 * 1000; // 15 seconds per image
                this.fadeTransitionTime = 2000; // 2 seconds fade transition
                
                // Initialize screensaver
                this.init();
            }

            async init() {
                console.log('[Admin] Initializing screensaver system...');
                
                // Create screensaver HTML structure
                this.createScreensaverDOM();
                
                // Load screensaver images
                await this.loadScreensaverImages();
                
                // Set up activity listeners
                this.setupActivityListeners();
                
                // Start inactivity timer
                this.resetInactivityTimer();
                
                console.log(`[Admin] Screensaver initialized with ${this.images.length} images`);
                console.log(`[Admin] Will activate after ${this.inactivityTimeout / 60000} minutes of inactivity`);
            }

            createScreensaverDOM() {
                // Create screensaver container for admin
                const screensaverHTML = `
                    <div id="admin-screensaver-overlay" class="admin-screensaver-overlay">
                        <div class="admin-screensaver-content">
                            <div class="admin-screensaver-image-container">
                                <img id="admin-screensaver-image-current" class="admin-screensaver-image active" alt="Admin Screensaver">
                                <img id="admin-screensaver-image-next" class="admin-screensaver-image" alt="Admin Screensaver">
                            </div>
                        </div>
                    </div>
                `;
                
                // Add to document
                document.body.insertAdjacentHTML('beforeend', screensaverHTML);
                
                // Add CSS styles for admin screensaver
                this.addScreensaverCSS();
            }

            addScreensaverCSS() {
                const style = document.createElement('style');
                style.textContent = `
                    .admin-screensaver-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100vw;
                        height: 100vh;
                        background: #000;
                        z-index: 10000;
                        display: none;
                        cursor: pointer;
                    }

                    .admin-screensaver-content {
                        position: relative;
                        width: 100%;
                        height: 100%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .admin-screensaver-image-container {
                        position: relative;
                        width: 100%;
                        height: 100%;
                        overflow: hidden;
                    }

                    .admin-screensaver-image {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        object-fit: cover;
                        object-position: center;
                        opacity: 0;
                        transition: opacity ${this.fadeTransitionTime}ms ease-in-out;
                    }

                    .admin-screensaver-image.active {
                        opacity: 1;
                    }
                `;
                document.head.appendChild(style);
            }

            async loadScreensaverImages() {
                // Use same images as main screensaver
                const imageFilenames = [
                    'rune-bearers-logo.jpg',
                    'rune_realm_split_lg.jpg',
                    'rTILr0z3AMaKmYxkc9R1--0--g5n89.jpg',
                    'kCDZjwiZg9NyUQhKhNCO--0--tsz0i.jpg',
                    'GoW1qnKJT7h42etBhdbS--0--13xeo.jpg',
                    'imsookasqlqLHuR8oojt--0--b3aak.jpg',
                    'xFyP5bcNmeWOYCQEHrB9--0--n5sr7.jpg',
                    'LSJNuZzUDEB7oXQNnvCt--1--sy7zm.jpg'
                    // Using fewer images for admin interface
                ];

                // Preload images
                const loadPromises = imageFilenames.map(filename => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            this.images.push(`assets/screensaver/${filename}`);
                            resolve();
                        };
                        img.onerror = () => {
                            console.warn(`[Admin] Failed to load screensaver image: ${filename}`);
                            resolve();
                        };
                        img.src = `assets/screensaver/${filename}`;
                    });
                });

                await Promise.all(loadPromises);
                this.shuffleImages();
                this.isLoading = false;
                console.log(`[Admin] Screensaver loaded ${this.images.length} images successfully`);
            }

            shuffleImages() {
                for (let i = this.images.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.images[i], this.images[j]] = [this.images[j], this.images[i]];
                }
            }

            setupActivityListeners() {
                const activityEvents = [
                    'mousedown', 'mousemove', 'mouseup',
                    'touchstart', 'touchmove', 'touchend',
                    'keydown', 'keypress', 'keyup',
                    'click', 'scroll', 'wheel'
                ];

                activityEvents.forEach(event => {
                    document.addEventListener(event, (e) => {
                        // Ignore activity from admin screensaver button clicks
                        if (e.target && e.target.onclick && 
                            e.target.onclick.toString().includes('activateAdminScreensaver')) {
                            return;
                        }
                        
                        if (this.isActive) {
                            this.deactivateScreensaver();
                        } else {
                            this.resetInactivityTimer();
                        }
                    }, { passive: true });
                });

                // Specific listener for admin screensaver overlay
                document.addEventListener('DOMContentLoaded', () => {
                    const overlay = document.getElementById('admin-screensaver-overlay');
                    if (overlay) {
                        overlay.addEventListener('click', () => {
                            this.deactivateScreensaver();
                        });
                    }
                });
            }

            resetInactivityTimer() {
                if (this.isActive) return;
                
                clearTimeout(this.inactivityTimer);
                this.inactivityTimer = setTimeout(() => {
                    this.activateScreensaver();
                }, this.inactivityTimeout);
            }

            activateScreensaver() {
                if (this.isActive || this.isLoading || this.images.length === 0) return;
                
                console.log('[Admin] Activating screensaver...');
                this.isActive = true;
                
                clearTimeout(this.inactivityTimer);
                
                const overlay = document.getElementById('admin-screensaver-overlay');
                if (overlay) {
                    overlay.style.display = 'block';
                    this.startSlideshow();
                }
            }

            deactivateScreensaver() {
                if (!this.isActive) return;
                
                console.log('[Admin] Deactivating screensaver...');
                this.isActive = false;
                
                this.stopSlideshow();
                
                const overlay = document.getElementById('admin-screensaver-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
                
                this.resetInactivityTimer();
            }

            startSlideshow() {
                if (this.images.length === 0) return;
                
                this.currentImageIndex = 0;
                this.showCurrentImage();
                
                this.slideTimer = setInterval(() => {
                    this.nextImage();
                }, this.slideInterval);
            }

            stopSlideshow() {
                clearInterval(this.slideTimer);
                this.slideTimer = null;
            }

            showCurrentImage() {
                const currentImg = document.getElementById('admin-screensaver-image-current');
                const nextImg = document.getElementById('admin-screensaver-image-next');
                
                if (currentImg && this.images[this.currentImageIndex]) {
                    currentImg.src = this.images[this.currentImageIndex];
                    currentImg.classList.add('active');
                    nextImg.classList.remove('active');
                }
            }

            nextImage() {
                if (this.images.length === 0) return;
                
                const currentImg = document.getElementById('admin-screensaver-image-current');
                const nextImg = document.getElementById('admin-screensaver-image-next');
                
                this.currentImageIndex = (this.currentImageIndex + 1) % this.images.length;
                nextImg.src = this.images[this.currentImageIndex];
                
                setTimeout(() => {
                    currentImg.classList.remove('active');
                    nextImg.classList.add('active');
                    
                    setTimeout(() => {
                        const tempSrc = currentImg.src;
                        currentImg.src = nextImg.src;
                        nextImg.src = tempSrc;
                        
                        currentImg.classList.add('active');
                        nextImg.classList.remove('active');
                    }, this.fadeTransitionTime);
                }, 100);
            }

            forceActivate() {
                this.activateScreensaver();
            }

            forceDeactivate() {
                this.deactivateScreensaver();
            }

            setInactivityTimeout(minutes) {
                this.inactivityTimeout = minutes * 60 * 1000;
                console.log(`[Admin] Screensaver timeout set to ${minutes} minutes`);
                this.resetInactivityTimer();
            }

            getStatus() {
                return {
                    isActive: this.isActive,
                    imageCount: this.images.length,
                    currentImageIndex: this.currentImageIndex,
                    inactivityTimeoutMinutes: this.inactivityTimeout / 60000,
                    slideIntervalSeconds: this.slideInterval / 1000
                };
            }
        }

        // Initialize admin screensaver manager
        const adminScreensaverManager = new AdminScreensaverManager();

        // Expose admin screensaver functions
        window.testAdminScreensaver = function() {
            adminScreensaverManager.forceActivate();
        };

        window.stopAdminScreensaver = function() {
            adminScreensaverManager.forceDeactivate();
        };

        window.setAdminScreensaverTimeout = function(minutes) {
            adminScreensaverManager.setInactivityTimeout(minutes);
        };

        window.getAdminScreensaverStatus = function() {
            return adminScreensaverManager.getStatus();
        };

        // Function for the admin screensaver button
        window.activateAdminScreensaver = function() {
            console.log('Admin screensaver button clicked');
            // Add small delay to avoid race condition with click event
            setTimeout(() => {
                adminScreensaverManager.forceActivate();
            }, 100);
        };

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'u':
                        e.preventDefault();
                        unlockNextDay();
                        break;
                    case 'r':
                        e.preventDefault();
                        if (e.shiftKey) {
                            resetProgress();
                        }
                        break;
                    case 't':
                        e.preventDefault();
                        toggleResetPanel();
                        break;
                    case 's':
                        e.preventDefault();
                        if (e.shiftKey) {
                            // Ctrl+Shift+S to test screensaver
                            testAdminScreensaver();
                        }
                        break;
                }
            }
        });

        console.log('[Admin] Rune Bearer Phoenix admin interface initialized with sound effects and screensaver');

        // Admin URL Commands - allows remote control via URL parameters
        // Example: yoursite.com?admin=unlock&day=10&key=RB25Admin
        function checkAdminCommands() {
            const urlParams = new URLSearchParams(window.location.search);
            const adminCmd = urlParams.get('admin');
            const adminKey = urlParams.get('key');
            
            // Change this key to something secure!
            const ADMIN_KEY = 'RB25Admin2025';
            
            if (adminKey === ADMIN_KEY && adminCmd) {
                console.log('Admin command received:', adminCmd);
                
                switch(adminCmd) {
                    case 'unlock':
                        const day = parseInt(urlParams.get('day') || '1');
                        const wells = urlParams.get('wells') || day;
                        const rou = urlParams.get('rou') || day;
                        
                        // Set player progress
                        (async () => {
                            const gameData = await loadGameData();
                            gameData.wells.currentDay = parseInt(wells);
                            gameData.rou.currentDay = parseInt(rou);
                            gameData.lastUpdated = Date.now() + 1000000; // Future timestamp
                            gameData.device = 'ADMIN_URL_COMMAND';
                            
                            await saveGameData(gameData);
                            
                            alert(`Admin: Set Wells to Day ${wells}, Rou to Day ${rou}`);
                            
                            // Clear URL parameters and reload
                            window.history.replaceState({}, document.title, window.location.pathname);
                            setTimeout(() => window.location.reload(), 1000);
                        })();
                        break;
                        
                    case 'reset':
                        if (confirm('Admin: Reset entire game to Day 1?')) {
                            (async () => {
                                await adminResetGame();
                                window.history.replaceState({}, document.title, window.location.pathname);
                            })();
                        }
                        break;
                        
                    case 'addrune':
                        const player = urlParams.get('player');
                        const rune = urlParams.get('rune');
                        
                        if (player && rune) {
                            (async () => {
                                const gameData = await loadGameData();
                                if (!gameData[player].collectedRunes.includes(rune)) {
                                    gameData[player].collectedRunes.push(rune);
                                    gameData.lastUpdated = Date.now() + 1000000;
                                    await saveGameData(gameData);
                                    alert(`Admin: Added ${rune} to ${player}`);
                                }
                                window.history.replaceState({}, document.title, window.location.pathname);
                                setTimeout(() => window.location.reload(), 1000);
                            })();
                        }
                        break;
                        
                    case 'status':
                        (async () => {
                            const gameData = await loadGameData();
                            alert(`Admin Status:\n\nWells: Day ${gameData.wells.currentDay}, Runes: ${gameData.wells.collectedRunes.length}\nRou: Day ${gameData.rou.currentDay}, Runes: ${gameData.rou.collectedRunes.length}\n\nLast Updated: ${new Date(gameData.lastUpdated).toLocaleString()}`);
                            window.history.replaceState({}, document.title, window.location.pathname);
                        })();
                        break;
                }
            }
        }

        // Call this function early in your initialization
        document.addEventListener('DOMContentLoaded', () => {
            checkAdminCommands();
        });
    </script>

    <!-- Firebase Remote Control Functions -->
    <script>
        // Firebase Remote Control Functions
        async function pushCurrentSaveAsMaster() {
            try {
                const gameData = JSON.parse(localStorage.getItem('runeBearerSave') || '{}');
                
                if (!gameData.wells || !gameData.rou) {
                    alert('No local game data found! Load the game first.');
                    return;
                }
                
                gameData.lastUpdated = Date.now() + 1000000;
                gameData.device = 'ADMIN_CHECKLIST_MASTER';
                gameData.isMasterSave = true;
                
                const saveRef = firebaseDB.ref('saves/family_rb25');
                await saveRef.set(gameData);
                
                document.getElementById('firebaseStatus').textContent = 
                    `✅ Master save pushed! Wells: Day ${gameData.wells.currentDay}, Rou: Day ${gameData.rou.currentDay}`;
                
                alert('Success! This save is now the master. All devices will sync to this.');
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        async function viewFirebaseSave() {
            try {
                const saveRef = firebaseDB.ref('saves/family_rb25');
                const snapshot = await saveRef.once('value');
                const cloudSave = snapshot.val();
                
                if (cloudSave) {
                    const status = `☁️ Cloud: Wells Day ${cloudSave.wells?.currentDay || 1}, ` +
                                `Rou Day ${cloudSave.rou?.currentDay || 1} | ` +
                                `Updated: ${new Date(cloudSave.lastUpdated).toLocaleString()}`;
                    
                    document.getElementById('firebaseStatus').textContent = status;
                    document.getElementById('remoteWellsDay').value = cloudSave.wells?.currentDay || 1;
                    document.getElementById('remoteRouDay').value = cloudSave.rou?.currentDay || 1;
                } else {
                    document.getElementById('firebaseStatus').textContent = '❌ No cloud save found!';
                }
            } catch (error) {
                document.getElementById('firebaseStatus').textContent = '❌ Error: ' + error.message;
            }
        }

        async function pullFromCloud() {
            try {
                const saveRef = firebaseDB.ref('saves/family_rb25');
                const snapshot = await saveRef.once('value');
                const cloudSave = snapshot.val();
                
                if (cloudSave) {
                    localStorage.setItem('runeBearerSave', JSON.stringify(cloudSave));
                    document.getElementById('firebaseStatus').textContent = 
                        `✅ Pulled cloud save to this device! Refresh to see changes.`;
                    
                    setTimeout(() => location.reload(), 2000);
                } else {
                    alert('No cloud save to pull!');
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        async function forceCloudSync() {
            try {
                const saveRef = firebaseDB.ref('saves/family_rb25');
                const snapshot = await saveRef.once('value');
                const cloudSave = snapshot.val();
                
                if (cloudSave) {
                    cloudSave.lastUpdated = Date.now() + 2000000;
                    cloudSave.forceSync = true;
                    await saveRef.set(cloudSave);
                    
                    document.getElementById('firebaseStatus').textContent = '🔄 Force sync activated!';
                    alert('All devices will update to this save on next load!');
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        async function setRemoteProgress() {
            try {
                const wellsDay = parseInt(document.getElementById('remoteWellsDay').value);
                const rouDay = parseInt(document.getElementById('remoteRouDay').value);
                
                const saveRef = firebaseDB.ref('saves/family_rb25');
                const snapshot = await saveRef.once('value');
                let cloudSave = snapshot.val() || {};
                
                cloudSave.wells = cloudSave.wells || {};
                cloudSave.rou = cloudSave.rou || {};
                cloudSave.wells.currentDay = wellsDay;
                cloudSave.rou.currentDay = rouDay;
                cloudSave.lastUpdated = Date.now() + 1000000;
                cloudSave.device = 'ADMIN_SET_PROGRESS';
                
                // Also update local if it exists
                const localSave = JSON.parse(localStorage.getItem('runeBearerSave') || '{}');
                if (localSave.wells) {
                    localSave.wells.currentDay = wellsDay;
                    localSave.rou.currentDay = rouDay;
                    localStorage.setItem('runeBearerSave', JSON.stringify(localSave));
                }
                
                await saveRef.set(cloudSave);
                
                document.getElementById('firebaseStatus').textContent = 
                    `✅ Cloud updated: Wells Day ${wellsDay}, Rou Day ${rouDay}`;
                
                // Update the checklist display
                updateProgressDisplay();
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        // Auto-check cloud status on load
        setTimeout(viewFirebaseSave, 1500);
    </script>
</body>
</html> 